一、List
1、ArrayList
ArrayList类扩展AbstractList并执行List接口。ArrayList支持可随需要而增长的动态数组。
本质上，ArrayList是对象引用的一个变长数组。
可以通过ensureCapacity()方法人工地增加ArrayList的容量。如果事先知道长度有多大，在开始时，通过一次性地增加
它的容量，就能避免后面的再分配。因为再分配是很花时间的，避免不必要的处理可以提高性能。

2、LinkedList类扩展了AbstractSequentialList类并实现List接口。它提供了一个链表的数据结构。


二、Set
一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 
的元素对 e1 和 e2，并且最多包含一个 null 元素。

1、HashSet
HashSet扩展AbstractSet并且实现Set接口。它创建一个类集，该类集使用散列
表进行存储。而散列表通过使用称之为散列法的机制来存储信息。

在散列（hashing）中，一个关键字的信息内容被用来确定唯一的一个值，成为散列码（hash code）。而散列码被
用来当做与关键字相连的数据的存储下标。关键字到其散列码的转换是自动执行的--看不到散列码本身。程序代码
也不能直接索引散列表。
散列法的优点在于：即使对于大的集合，它允许一些基本操作。

注意散列集合并不能确定其元素的排列顺序，因为散列法的处理通常
不让自己参与创建排序集合。如果需要排序存储，另一种类集――TreeSet 将是一个
更好的选择。

2、TreeSet
TreeSet 为使用树来进行存储的 Set 接口提供了一个工具，对象按升序存储。访问
和检索是很快的。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet
是一个很好的选择。


三、Map
1、SortedMap

2、HashMap
实现原理：
HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
HashMap底层就是一个数组结构，数组中的每一项又是一个链表。

假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。
迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）
成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。

HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶的数量，
初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。
当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（
即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 

通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，
但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。
在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。
如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 

Entry就是数组中的元素，每个 HashMapEntry.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，
这就构成了链表。

当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组
中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式
存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组
中的该位置上。


3、TreeMap
TreeMap 类通过使用树实现 Map 接口。TreeMap 提供了按排序顺序存储“关键字
/值”对的有效手段，同时允许快速检索。应该注意的是，不像散列映射，树映射保证
它的元素按照关键字升序排序


四、Vector
Vector 实现动态数组。这与 ArrayList 相似，但两者不同的是：Vector 是同步的，
并且它包含了许多不属于类集框架的从以前版本遗留下来的方法。


五、Properties
属性（Properties）是Hashtable的一个子类。它用来保持值的列表，在其中关
键字和值都是字符串（String）。Properties类被许多其它的Java类所使用。

Properties 的一个最有用的方面是可以利用 store()和 load()方法方便地对包含在属
性（Properties）对象中的信息进行存储或从盘中装入信息。在任何时候，都可以将一
个属性（Properties）对象写入流或从流中将其读出。这使得属性列表特别方便实现简
单的数据库。

六、对象克隆
“对象克隆（clone）”实际上是指将对象重新复制一份。

如何实现对象的克隆：
1、实现Cloneable接口；
2、覆盖Object类中的clone方法
























































































