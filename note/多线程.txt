一、进程与线程

进程是程序的一次动态执行过程，它经历了从代码加载、执行到执行完毕的一个
完整过程，这个过程也是进程本身从产生、发展到最终消亡的过程。

线程是比进程更小的执行单位，线程是进程内部单一的一个顺序控制流。

多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，形成多条执行线索。

线程和进程的主要差别：
1）、同样作为基本的执行单元，线程是划分得比进程更小的执行单位。
2）、每个进程都有一段专用的内存区域。与此相反，线程却是共享内存单元（包括代码和数据），
通过共享内存单元来实现数据交换，实时通信与必要的同步操作。


两种多线程实现机制的比较：
Thread 类实现了 Runnable 接口，也就是说 Thread 类也是Runnable 接口的一个子类。
一个类继承Thread类之后，这个类对象无论调用多少次start()方法，结果都只有一个线程在运行。
用继承Thread类实际上无法达到资源共享的目的。

实现Runnable接口相对于继承Thread类优势：
1）、适合多个相同程序代码的线程去处理同一资源的情况，把线程同程序的代码、数据有效分离，较好体现了面向对象的设计思想。
2）、可以避免由于Java的单继承带来的局限性。
3）、增强了程序的健壮性。代码能够被多个线程共享，代码与数据是独立。
当多个线程的执行代码来自同一个类的实例时，即称它们共享相同的代
码。多个线程可以操作相同的数据，与它们的代码无关。当共享访问相
同的对象时，即共享相同的数据。当线程被构造时，需要的代码和数据
通过一个对象作为构造函数实参传递进去，这个对象就是一个实现了
Runnable 接口的类的实例。

二、Thread类主要方法：
join():等待线程死亡；
join(long millis):等待millis毫秒后，线程死亡
setPriority():设定线程的优先值；
sleep(long millis):使正在执行的线程休眠millis毫秒；
yield():将目前正在执行的线程暂停，允许其他线程执行；

三、后台线程与 setDaemon()方法
只要还有一个前台线程在运行，这个进程就不会结束，如果一个进程中只有后台线程在运行，这个进程就会结束。

如果某个线程对象在启动（调用start()方法）之前调用了setDaemon(true)方法，这个线程就会变成后台线程。

四、线程的强制运行：
join() -- 强制运行完一线程后，再运行后面的线程

五、多线程的同步
synchronized
1、同步代码块：
即当一个线程运行到特定代码后，CPU 不去执行其它线程中的、可能影响当前
线程中的下一句代码的执行结果的代码块，必须等到下一句执行完后才能去执行其它
线程中的有关代码块。
程序中不能有多个线程同时在这两句代码之间执行，这就是线程同步。

2、同步方法
访问控制符 synchronized 返回值类型 方法名称(参数) {}

3、死锁
如果有一组进程或者线程，其中每个都在等待一个只有其他进程或线程才可以执行的操作，那么就称它们被死锁了。

最常见的死锁形式是当线程 1 持有对象 A 上的锁，而且正在等待对象 B 上的
锁；而线程 2 持有对象 B 上的锁，却正在等待对象 A 上的锁。这两个线程永远都
不会获得第二个锁，或是释放第一个锁，所以它们只会永远等待下去。

要避免死锁，应该确保在获取多个锁时，在所有的线程中都以相同的顺序获取锁。

六、线程间通讯
Java是通过Object类的wait,notify,notifyAll这几个方法来实现线程间的通信的。

wait:告诉当前线程放弃监视器并进入睡眠状态，直到其他线程进入同一监视器并调用notify为止。

notify：唤醒同一对象监视器中调用wait的第一个线程。类似排队买票，一个人买完之后，后面的人可以继续买。

notifyAll：唤醒同一对象监视器中调用wait的所有线程，具有最高优先级的线程首先被唤醒并执行。

wait、notify、notifyAll 这三个方法只能在 synchronized 方法中调用，即无论线程
调用一个对象的 wait 还是 notify 方法，该线程必须先得到该对象的锁标记，这样，notify
只能唤醒同一对象监视器中调用 wait 的线程，使用多个对象监视器，就可以分别有多
个 wait、notify 的情况，同组里的 wait 只能被同组的 notify 唤醒。

七、线程生命周期的控制
控制线程生命周期的方法有：suspend,resume,stop方法。但这三个方法都不推荐使用。
其中不推荐使用suspend和resume的原因是：
1）、会导致死锁的发生。
2）、它允许一个线程通（甲）过直接控制另外一个线程（乙）的代码来直接控制那个线程（乙）

虽然stop能够避免死锁的发生，但是它也有其他的补足：如果一个线程正在操作共享数据段，操作过程没有完成就被stop了的话，将会导致数据的不完整性。

通过控制run方法中的条件来结束一个线程的方法是推荐使用的








































